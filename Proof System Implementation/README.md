- [Proof System Implementation](#proof-system-implementation)
  - [External crates](#external-crates)
    - [`merlin`](#merlin)
    - [`arkworks` ecosystem](#arkworks-ecosystem)
  - [Elliptic curve of choice](#elliptic-curve-of-choice)
  - [Usage of the library](#usage-of-the-library)
    - [*ZeroMT* full proof system](#zeromt-full-proof-system)
    - [*Bulletproofs* aggregated range proof](#bulletproofs-aggregated-range-proof)
    - [$\Sigma$-protocol `sk`](#sigma-protocol-sk)
    - [$\Sigma$-protocol `r`](#sigma-protocol-r)
    - [$\Sigma$-protocol `ab`](#sigma-protocol-ab)
    - [$\Sigma$-protocol `y`](#sigma-protocol-y)

# Proof System Implementation
As the *ZeroMT* multi-transfer zero-knowledge proof system can be seen as a combination of multiple proof systems, the objective of its implementation is a library that exposes each proof system in a non-interactive form, as a single, modular unit. Given the modular design, any given user should be enabled to include in any possible application either the overall *ZeroMT* proof system or just a few of the available proof systems. Furthermore, this design permits the evaluation of the performances, in terms of execution time and memory utilization, of each of the implemented protocols.

The language that has been chosen for the implementation is **Rust** as it offers a fast way to prototype a memory-efficient program while offering a wide variety of third-party packages, there called *crates*, by means of the Cargo package manager and the community’s crate registry *crates.io*.
  
This codebase includes both the logic behind the *ZeroMT* proof system and each of the underlying proof systems from *Bulletproofs* and the four other $\Sigma$-protocols. Furthermore, it also includes a test suite to ensure the correctness of the code and a benchmarking portion aimed at the performance evaluation presented in this thesis work.

## External crates
### `merlin`

[`merlin`](https://github.com/zkcrypto/merlin) is a library that offers a Fiat-Shamir heuristic for building non-interactive proof systems by means of a STROBE based transcript while implementing such systems as if they were interactive (public-coin). 

The result of the use of `merlin` for both the prover and the verifier within a proof system codebase is the generation of a single proof message to be exchanged between the parties. Prior to the proof exchange, both the prover and the verifier interact with a transcript that models all the interaction that would occur with the opposed party. Basically, every time that, by protocol definition, a prover has to send either a scalar or an elliptic curve point to a verifier such forwarding is replaced with an interaction with the transcript, that updates its internal state with the new values. When it comes to the forwarding of a randomly-computed challenge value from the verifier to the prover the transcript comes in and generates itself a challenge value for the prover. After the prover has ended following the protocol specification, a proof is generated by combining all the elements that the prover inserted in its transcript. When given such proof, the verifier syncs its own transcript by feeding it with the same elements in the same order the prover followed.

By maintaining a pair of transcripts that are consistent for both the prover and the verifier, `merlin` ensures the correctness of the implemented protocol, hence ensuring that all the generated elements have the same values on both sides.
The peculiarity of the `merlin`'s transcript is that they can be used in multiple proof systems sequentially, as long as they are in the same order on both the prover and the verifier side. 

### `arkworks` ecosystem

Crucial for the implementation of a proof system is a library that provides all the arithmetic behind elliptic curve points and finite fields elements, i.e. all the elements that are manipulated during the protocols. All the necessities of the implementation have been fullfilled by the [`arkworks`](https://github.com/arkworks-rs) ecosystem for proof systems programming in Rust.

Moreover, the `arkworks` libraries have been employed to also include serialization and deserialization processes for both elliptic curves point and finite fields elements in the `merlin` transcript logic and in the codebase that has been written for benchmarking purposes.

## Elliptic curve of choice

For what concerns the elliptic curve underlying all the operations on elements of $\mathbb{G}$, for this first complete implementation of the ZeroMT proof systems the Barreto–Naehrig curve **BN-254** has been chosen.

## Usage of the library

### *ZeroMT* full proof system
To prove that
- each of the currency amounts in $\mathbf{a}$ is positive $$\forall a_i \in (a_1, \dots, a_{m-1}): a_i \in [0,MAX], \; MAX = 2^n - 1;$$
- sender remaining currency balance $b'$ after the transfer  is positive $$b' \in [0,MAX], \; MAX = 2^n - 1;$$
- a sender knows a secret private key $sk$ for which the respective public key $y$ encrypts the values in $\textbf{C}$ and the such public key is well-formed  $$y = sk \cdot g;$$
- a sender knows a randomness value $r$ to be used in the encryption process for which $$D = r \cdot g;$$
- a sender balance cannot be overdraft, i.e. the sender remaining encrypted balance is equal to the subtraction between the current sender encrypted balance and all of the $(m-1)$ encrypted currency amounts contained in $\mathbf{C}$ $$C_L - \sum_{i=1}^{m-1}C_i = b' \cdot g + sk \cdot (C_R- \sum_{i=1}^{m-1}D);$$
- the i-th values in both $\textbf{C}$ and $\bar{\textbf{C}}$ are well-formed and are the result of the encryption of the i-th currency amount to be transferred $$(C_{i}=a_{i} \cdot g + r \cdot y \wedge \bar{C}_{i}=a_{i} \cdot g + {r} \cdot \bar{y}_{i} \wedge D=r \cdot g)^{m-1}_{i=1}.$$

Prover $\mathcal{P}$ inputs:
- Random Number Generator in `rand::Rng`;
- A `merlin` transcript;
- $n$, dimension in bits of the range proof;
- $g \in \mathbb{G}$, random generator;
- $h \in \mathbb{G}$, random generator;
- $\mathbf{g} \in \mathbb{G}^{m \cdot n}$, vector of random generators;
- $\mathbf{h} \in \mathbb{G}^{m \cdot n}$, vector of random generators;
- $\mathbf{a} \in \mathbb{Z}_p^{m-1}$, cryptocurrency amounts to be transferred;
- $b' \in \mathbb{Z}_p$, sender remaining balance;
- $u \in \mathbb{G}$, random generator required for the inner-product argument;
- $r \in \mathbb{Z}_p$, randomness associated with the ElGamal encryption scheme;
- $D \in \mathbb{G}$, factor for ElGamal scheme;
- $C_R \in \mathbb{G}$, right side of the sender balance, encrypted by means of ElGamal encryption and sender public key;
- $sk \in \mathbb{Z}_p$, sender private key;
- $y \in \mathbb{G}$, sender public key;
- $\bar{\mathbf{y}} \in \mathbb{G}^{m-1}$, recipients' public keys.

Verifier $\mathcal{V}$ inputs:
- A `merlin` transcript;
- $n$, dimension in bits of the range proof;
- $g \in \mathbb{G}$, random generator;
- $h \in \mathbb{G}$, random generator;
- $\mathbf{g} \in \mathbb{G}^{m \cdot n}$, vector of random generators;
- $\mathbf{h} \in \mathbb{G}^{m \cdot n}$, vector of random generators;
- $u \in \mathbb{G}$, random generator required for the inner-product argument;
- $D \in \mathbb{G}$, factor for ElGamal scheme;
- $C_L \in \mathbb{G}$, left side of the sender balance, encrypted by means of ElGamal encryption and sender public key;
- $C_R \in \mathbb{G}$, right side of the sender balance, encrypted by means of ElGamal encryption and sender public key;
- $\mathbf{C} \in \mathbb{G}^{m-1}$, cryptocurrency amounts, encrypted by means of ElGamal encryption and sender public key;
- $\bar{\mathbf{C}} \in \mathbb{G}^{m-1}$, cryptocurrency amounts, encrypted by means of ElGamal encryption and recipients' public keys;
- $y \in \mathbb{G}$, sender public key;
- $\bar{\mathbf{y}} \in \mathbb{G}^{m-1}$, recipients' public keys.
```rust
use std::io::Error;
use ark_bn254::{Fr as ScalarField, G1Affine as G1Point};
use merlin::Transcript;
use serial_test::serial;
use zeromt::{ElGamal, Utils, ZeroMTProof, ZeroMTProver, ZeroMTVerifier};

// Random Number Generator
let mut rng = ark_std::rand::thread_rng();
// Number of cryptocurrency amounts to be transferred (increased by one)
let mut m: usize = 16;
// Dimension in bit of the range proof
let mut n: usize = 16;
// Prover transcript setup
let mut prover_trans: Transcript = Transcript::new(b"ZeroMTTest");
// Verifier transcript setup
let mut verifier_trans: Transcript = Transcript::new(b"ZeroMTTest");
// Random generator g
let g: G1Point = Utils::get_n_generators_berkeley(1, &mut rng)[0];
// Random generator h
let h: G1Point = Utils::get_n_generators_berkeley(1, &mut rng)[0];
// Randomness r
let r: ScalarField = Utils::get_n_random_scalars_not_zero(1, &mut rng)[0];
// Random generator u
let u: G1Point = Utils::get_n_generators_berkeley(1, &mut rng)[0];
// Vector g of random generators
let g_vec: Vec<G1Point> = Utils::get_n_generators_berkeley(m * n, &mut rng);
// Vector h of random generators
let h_vec: Vec<G1Point> = Utils::get_n_generators_berkeley(m * n, &mut rng);
// Random values for sender balance and cryptocurrency amounts to be transferred
let (balance, amounts, balance_remaining) = Utils::get_mock_balances(m, n, &mut rng);
// Random sender private key
let sender_priv_key: ScalarField = Utils::get_n_random_scalars_not_zero(1, &mut rng)[0];
// Random recipients private keys
let recipients_priv_keys: Vec<ScalarField> = Utils::get_n_random_scalars_not_zero(amounts.len(), &mut rng);
// Sender public key, generated by means of ElGamal encryption
let sender_pub_key: G1Point = ElGamal::elgamal_calculate_pub_key(&sender_priv_key, &g);
// Recipients' public keys, generated by means of ElGamal encryption
let recipients_pub_keys: Vec<G1Point> = recipients_priv_keys.iter().map(|key: &ScalarField| ElGamal::elgamal_calculate_pub_key(key, &g)).collect();
// Sender balance, encrypted by means of ElGamal encryption and sender public key
let (c_l, c_r): (G1Point, G1Point) = ElGamal::elgamal_encrypt(balance, &sender_pub_key, &g, &r);
// Factor D for ElGamal scheme
let d: G1Point = ElGamal::elgamal_d(&g, &r);
// Cryptocurrency amounts, encrypted by means of ElGamal encryption and sender public key
let c_vec: Vec<G1Point> = amounts.iter().map(|a: &usize| ElGamal::elgamal_encrypt(*a, &sender_pub_key, &g, &r).0).collect();
// Cryptocurrency amounts, encrypted by means of ElGamal encryption and recipients' public keys
let c_bar_vec: Vec<G1Point> = amounts.iter().zip(recipients_pub_keys.iter()).map(|(a, k)| ElGamal::elgamal_encrypt(*a, k, &g, &r).0).collect();

// Proof generation
let proof: ZeroMTProof = ZeroMTProver::new(&mut prover_trans, &g, &h, balance_remaining, &amounts, &g_vec, &h_vec, &u, n, &d, &c_r, &sender_priv_key, &r, &sender_pub_key, &recipients_pub_keys).generate_proof(&mut rng);
// Proof verification
let verification_result: Result<(), Error> = ZeroMTVerifier::new(&mut verifier_trans, &g, &h, n, &g_vec, &h_vec, &u, &d, &c_r, &c_l, &c_vec, &c_bar_vec, &sender_pub_key, &recipients_pub_keys).verify_proof(&proof);
```

### *Bulletproofs* aggregated range proof and inner-product argument
To prove that
- each of the currency amounts in $\mathbf{a}$ is positive
    $$\forall a_i \in (a_1, \dots, a_{m-1}): a_i \in [0,MAX], \; MAX = 2^n - 1;$$
- sender remaining currency balance $b'$ after the transfer  is positive
    $$b' \in [0,MAX], \; MAX = 2^n - 1.$$

Prover $\mathcal{P}$ inputs:
- Random Number Generator in `rand::Rng`;
- A `merlin` transcript;
- $n$, dimension in bits of the range proof;
- $g \in \mathbb{G}$, random generator;
- $h \in \mathbb{G}$, random generator;
- $\mathbf{g} \in \mathbb{G}^{m \cdot n}$, vector of random generators;
- $\mathbf{h} \in \mathbb{G}^{m \cdot n}$, vector of random generators;
- $\mathbf{a} \in \mathbb{Z}_p^{m-1}$, cryptocurrency amounts to be transferred;
- $b' \in \mathbb{Z}_p$, sender remaining balance;
- $u \in \mathbb{G}$, random generator required for the inner-product argument;
- $\mathbf{l} \in \mathbb{Z}_p^{m \cdot n}$, former element involved in the inner product to be verified; 
- $\mathbf{r} \in \mathbb{Z}_p^{m \cdot n}$, latter element involved in the inner product to be verified;
- $c \in \mathbb{Z}_p$, inner product to verify. Obtained from the range proof as $\hat{t} = \langle \mathbf{l}, \mathbf{r} \rangle$;
- $P \in \mathbb{G}$, commitment to elements involved in an inner product. Obtained from the range proof as $P - \mu \cdot h$.

Verifier $\mathcal{V}$ inputs:
- A `merlin` transcript;
- $n$, dimension in bits of the range proof;
- $m$, number of cryptocurrency amounts to be transferred (increased by one);
- $g \in \mathbb{G}$, random generator;
- $h \in \mathbb{G}$, random generator;
- $\mathbf{g} \in \mathbb{G}^{m \cdot n}$, vector of random generators;
- $\mathbf{h} \in \mathbb{G}^{m \cdot n}$, vector of random generators;
- $u \in \mathbb{G}$, random generator required for the inner-product argument;
- $c \in \mathbb{Z}_p$, inner product to verify. Obtained from the range proof as $\hat{t} = \langle \mathbf{l}, \mathbf{r} \rangle$;
- $P \in \mathbb{G}$, commitment to elements involved in an inner product. Obtained from the range proof as $P - \mu \cdot h$.
```rust
use ark_bn254::{Fr as ScalarField, G1Affine as G1Point};
use ark_ec::{AffineCurve, ProjectiveCurve};
use ark_ff::{Field, One, PrimeField};
use merlin::Transcript;
use std::io::Error;
use zeromt::{ InnerProof, InnerProver, InnerVerifier, RangeProof, RangeProver, RangeVerifier, Utils, };

// Random Number Generator
let mut rng = ark_std::rand::thread_rng();
// Number of cryptocurrency amounts to be transferred (increased by one)
let mut m: usize = 16;
// Dimension in bit of the range proof
let mut n: usize = 16;
// Prover transcript setup
let mut prover_trans: Transcript = Transcript::new(b"ZeroMTTest");
// Verifier transcript setup
let mut verifier_trans: Transcript = Transcript::new(b"ZeroMTTest");
// Random generator g
let g: G1Point = Utils::get_curve_generator();
// Random generator h
let h: G1Point = Utils::get_n_generators_berkeley(1, &mut rng)[0];
// Vector g of random generators
let g_vec: Vec<G1Point> = Utils::get_n_generators_berkeley(m * n, &mut rng);
// Vector h of random generators
let h_vec: Vec<G1Point> = Utils::get_n_generators_berkeley(m * n, &mut rng);
// Random values for sender balance and cryptocurrency amounts to be transferred
let (_balance_start, amounts, balance_remaining) = Utils::get_mock_balances(m, n, &mut rng);

// Range proof generation
let (range_proof, t_hat, l_poly_vec, r_poly_vec, _x, _y, _z): (RangeProof, ScalarField, Vec<ScalarField>, Vec<ScalarField>, ScalarField, ScalarField, ScalarField) = RangeProver::new(&mut prover_trans, &g, &h, balance_remaining, &amounts, &g_vec, &h_vec, n).generate_proof(&mut rng);
// Range proof verification
let (range_proof_result, x, y, z): (Result<(), Error>, ScalarField, ScalarField, ScalarField) = RangeVerifier::new(&mut verifier_trans, &g, &h, m, n).verify_proof(&range_proof);

// Random generator u
let u: G1Point = Utils::get_n_generators_berkeley(1, &mut rng)[0];
// Inner-product argument setup
let h_first_vec: Vec<G1Point> = (0..m * n).map(|i: usize| { h_vec[i].mul(y.pow([(i as u64)]).inverse().unwrap().into_repr()).into_affine() }).collect();
let p: G1Point = *range_proof.get_a() + range_proof.get_s().mul(x.into_repr()).into_affine() + -Utils::inner_product_point_scalar(&g_vec, &Utils::generate_scalar_exp_vector(m * n, &ScalarField::one())).unwrap().mul((z).into_repr()).into_affine() + Utils::inner_product_point_scalar(&h_first_vec, &Utils::generate_scalar_exp_vector(m * n, &y)).unwrap().mul((z).into_repr()).into_affine() + (1..=m).map(|j: usize| { Utils::inner_product_point_scalar(&h_first_vec[((j - 1) * n)..(j * n)].to_vec(), &Utils::generate_scalar_exp_vector(n, &ScalarField::from(2))).unwrap().mul((z.pow([1 + (j as u64)])).into_repr()).into_affine() }).sum::<G1Point>();
let phu: G1Point = p + -h.mul(range_proof.get_mu().into_repr()).into_affine();

// Inner-product argument proof generation
let inner_proof: InnerProof = InnerProver::new(&mut prover_trans, &g_vec, &h_first_vec, &phu, &t_hat, &l_poly_vec, &r_poly_vec, &u).generate_proof();
// Inner-product argument proof verification
let inner_result: Result<(), Error> = InnerVerifier::new(&mut verifier_trans, &g_vec, &h_first_vec, &phu, &t_hat, &u).verify_proof_multiscalar(&inner_proof);
```
### $\Sigma$-protocol `sk`
To prove a sender knows a secret private key $sk$ for which the respective public key $y$ encrypts the values in $\textbf{C}$ and the such public key is well-formed $$y = sk \cdot g.$$

Prover $\mathcal{P}$ inputs:
- Random Number Generator in `rand::Rng`;
- A `merlin` transcript;
- $g \in \mathbb{G}$, random generator;
- $sk \in \mathbb{Z}_p$, sender private key.

Verifier $\mathcal{V}$ inputs:
- A `merlin` transcript;
- $g \in \mathbb{G}$, random generator;
- $y \in \mathbb{G}$, sender public key.

```rust
use ark_bn254::{Fr as ScalarField, G1Affine as G1Point};
use ark_ec::{AffineCurve, ProjectiveCurve};
use ark_ff::PrimeField;
use merlin::Transcript;
use std::io::Error;
use zeromt::{SigmaSKProof, SigmaSKProver, SigmaSKVerifier, Utils, ElGamal};

// Random Number Generator
let mut rng = ark_std::rand::thread_rng();
// Number of cryptocurrency amounts to be transferred (increased by one)
let mut m: usize = 16;
// Dimension in bit of the range proof
let mut n: usize = 16;
// Prover transcript setup
let mut prover_trans: Transcript = Transcript::new(b"ZeroMTTest");
// Verifier transcript setup
let mut verifier_trans: Transcript = Transcript::new(b"ZeroMTTest");

// Random generator g
let g: G1Point = Utils::get_curve_generator();
// Random sender private key
let sk: ScalarField = Utils::get_n_random_scalars(1, &mut rng)[0];
// Sender public key, generated by means of ElGamal encryption
let y: G1Point = ElGamal::elgamal_calculate_pub_key(&sk, &g);

// Proof generation
let proof: SigmaSKProof = SigmaSKProver::new(&mut prover_trans, &g, &sk).generate_proof(&mut rng);
// Proof verification
let result: Result<(), Error> = SigmaSKVerifier::new(&mut verifier_trans, &g, &y).verify_proof(&proof);
                    
```
### $\Sigma$-protocol `r`
To prove a sender knows a randomness value $r$ to be used in the encryption process for which $$D = r \cdot g.$$

Prover $\mathcal{P}$ inputs:
- Random Number Generator in `rand::Rng`;
- A `merlin` transcript;
- $g \in \mathbb{G}$, random generator;
- $r \in \mathbb{Z}_p$, randomness associated with the ElGamal encryption scheme.

Verifier $\mathcal{V}$ inputs:
- A `merlin` transcript;
- $g \in \mathbb{G}$, random generator;
- $D \in \mathbb{G}$, factor for ElGamal scheme.
```rust
use ark_bn254::{Fr as ScalarField, G1Affine as G1Point};
use ark_ec::{AffineCurve, ProjectiveCurve};
use ark_ff::PrimeField;
use merlin::Transcript;
use std::io::Error;
use zeromt::{SigmaRProof, SigmaRProver, SigmaRVerifier, Utils, ElGamal};

// Random Number Generator
let mut rng = ark_std::rand::thread_rng();
// Number of cryptocurrency amounts to be transferred (increased by one)
let mut m: usize = 16;
// Dimension in bit of the range proof
let mut n: usize = 16;
// Prover transcript setup
let mut prover_trans: Transcript = Transcript::new(b"ZeroMTTest");
// Verifier transcript setup
let mut verifier_trans: Transcript = Transcript::new(b"ZeroMTTest");

// Random generator g
let g: G1Point = Utils::get_curve_generator();
// Randomness r
let r: ScalarField = Utils::get_n_random_scalars(1, &mut rng)[0];
// Factor D for ElGamal scheme
let d: G1Point = ElGamal::elgamal_d(&g, &r);

// Proof generation
let proof: SigmaRProof = SigmaRProver::new(&mut prover_trans, &g, &r).generate_proof(&mut rng);
// Proof verification
let result: Result<(), Error> = SigmaRVerifier::new(&mut verifier_trans, &g, &d).verify_proof(&proof);
```
### $\Sigma$-protocol `ab`

To prove a sender balance cannot be overdraft, i.e. the sender remaining encrypted balance is equal to the subtraction between the current sender encrypted balance and all of the $(m-1)$ encrypted currency amounts contained in $\mathbf{C}$ $$C_L - \sum_{i=1}^{m-1}C_i = b' \cdot g + sk \cdot (C_R- \sum_{i=1}^{m-1}D).$$

Prover $\mathcal{P}$ inputs:
- Random Number Generator in `rand::Rng`;
- A `merlin` transcript;
- $g \in \mathbb{G}$, random generator;
- $D \in \mathbb{G}$, factor for ElGamal scheme;
- $C_R \in \mathbb{G}$, right side of the sender balance, encrypted by means of ElGamal encryption and sender public key;
- $sk \in \mathbb{Z}_p$, sender private key;
- $\mathbf{a} \in \mathbb{Z}_p^{m-1}$, cryptocurrency amounts to be transferred;
- $b' \in \mathbb{Z}_p$, sender remaining balance.

Verifier $\mathcal{V}$ inputs:
- A `merlin` transcript;
- $g \in \mathbb{G}$, random generator;
- $D \in \mathbb{G}$, factor for ElGamal scheme;
- $C_L \in \mathbb{G}$, left side of the sender balance, encrypted by means of ElGamal encryption and sender public key;
- $C_R \in \mathbb{G}$, right side of the sender balance, encrypted by means of ElGamal encryption and sender public key;
- $\mathbf{C} \in \mathbb{G}^{m-1}$, cryptocurrency amounts, encrypted by means of ElGamal encryption and sender public key.

```rust
use ark_bn254::{Fr as ScalarField, G1Affine as G1Point};
use merlin::Transcript;
use std::io::Error;
use zeromt::{ElGamal, SigmaABProof, SigmaABProver, SigmaABVerifier, Utils};

// Random Number Generator
let mut rng = ark_std::rand::thread_rng();
// Number of cryptocurrency amounts to be transferred (increased by one)
let mut m: usize = 16;
// Dimension in bit of the range proof
let mut n: usize = 16;
// Prover transcript setup
let mut prover_trans: Transcript = Transcript::new(b"ZeroMTTest");
// Verifier transcript setup
let mut verifier_trans: Transcript = Transcript::new(b"ZeroMTTest");
// Random generator g
let g: G1Point = Utils::get_n_generators_berkeley(1, &mut rng)[0];
// Randomness r
let r: ScalarField = Utils::get_n_random_scalars_not_zero(1, &mut rng)[0];
// Random values for sender balance and cryptocurrency amounts to be transferred
let (balance, amounts, balance_remaining) = Utils::get_mock_balances(m, n, &mut rng);
// Random sender private key   
let sender_priv_key: ScalarField = Utils::get_n_random_scalars_not_zero(1, &mut rng)[0];
// Sender public key, generated by means of ElGamal encryption
let sender_pub_key: G1Point = ElGamal::elgamal_calculate_pub_key(&sender_priv_key, &g);
// Sender balance, encrypted by means of ElGamal encryption and sender public key
let (c_l, c_r): (G1Point, G1Point) = ElGamal::elgamal_encrypt(balance, &sender_pub_key, &g, &r);
// Factor D for ElGamal scheme
let d: G1Point = ElGamal::elgamal_d(&g, &r);
// Cryptocurrency amounts, encrypted by means of ElGamal encryption and sender public key
let c_vec: Vec<G1Point> = amounts.iter().map(|a:&usize| ElGamal::elgamal_encrypt(*a, &sender_pub_key, &g, &r).0).collect();

// Proof generation
let proof: SigmaABProof = SigmaABProver::new(&mut prover_trans, &g, &d, &c_r, balance_remaining, &amounts, &sender_priv_key).generate_proof(&mut rng);
// Proof verification
let result: Result<(), Error> = SigmaABVerifier::new(&mut verifier_trans, &g, &d, &c_r, &c_l, &c_vec).verify_proof(&proof);

```
### $\Sigma$-protocol `y`
To prove the i-th values in both $\textbf{C}$ and $\bar{\textbf{C}}$ are well-formed and are the result of the encryption of the i-th currency amount to be transferred $$(C_{i}=a_{i} \cdot g + r \cdot y \wedge \bar{C}_{i}=a_{i} \cdot g + {r} \cdot \bar{y}_{i} \wedge D=r \cdot g)^{m-1}_{i=1}.$$

Prover $\mathcal{P}$ inputs:
- Random Number Generator in `rand::Rng`;
- A `merlin` transcript;
- $y \in \mathbb{G}$, sender public key;
- $\bar{\mathbf{y}} \in \mathbb{G}^{m-1}$, recipients' public keys
- $r \in \mathbb{Z}_p$, randomness associated with the ElGamal encryption scheme.

Verifier $\mathcal{V}$ inputs:
- A `merlin` transcript;
- $y \in \mathbb{G}$, sender public key;
- $\bar{\mathbf{y}} \in \mathbb{G}^{m-1}$, recipients' public keys;
- $\mathbf{C} \in \mathbb{G}^{m-1}$, cryptocurrency amounts, encrypted by means of ElGamal encryption and sender public key;
- $\bar{\mathbf{C}} \in \mathbb{G}^{m-1}$, cryptocurrency amounts, encrypted by means of ElGamal encryption and recipients' public keys.


```rust
use ark_bn254::{Fr as ScalarField, G1Affine as G1Point};
use merlin::Transcript;
use std::io::Error;
use zeromt::{ElGamal, SigmaYProof, SigmaYProver, SigmaYVerifier, Utils};

// Random Number Generator
let mut rng = ark_std::rand::thread_rng();
// Number of cryptocurrency amounts to be transferred (increased by one)
let mut m: usize = 16;
// Dimension in bit of the range proof
let mut n: usize = 16;
// Prover transcript setup
let mut prover_trans: Transcript = Transcript::new(b"ZeroMTTest");
// Verifier transcript setup
let mut verifier_trans: Transcript = Transcript::new(b"ZeroMTTest");
// Random generator g
let g: G1Point = Utils::get_n_generators_berkeley(1, &mut rng)[0];
// Randomness r
let r: ScalarField = Utils::get_n_random_scalars_not_zero(1, &mut rng)[0];
// Random values for sender balance and cryptocurrency amounts to be transferred
let (_balance_start, amounts, _balance_remaining) = Utils::get_mock_balances(m, n, &mut rng);
// Random sender private key
let sender_priv_key: ScalarField = Utils::get_n_random_scalars_not_zero(1, &mut rng)[0];
// Random recipients private keys
let recipients_priv_keys: Vec<ScalarField> = Utils::get_n_random_scalars_not_zero(amounts.len(), &mut rng);
// Sender public key, generated by means of ElGamal encryption
let sender_pub_key: G1Point = ElGamal::elgamal_calculate_pub_key(&sender_priv_key, &g);
// Recipients' public keys, generated by means of ElGamal encryption
let recipients_pub_keys: Vec<G1Point> = recipients_priv_keys.iter().map(|key: &ScalarField| ElGamal::elgamal_calculate_pub_key(key, &g)).collect();
// Cryptocurrency amounts, encrypted by means of ElGamal encryption and sender public key
let c_vec: Vec<G1Point> = amounts.iter().map(|a: &usize| ElGamal::elgamal_encrypt(*a, &sender_pub_key, &g, &r).0).collect();
// Cryptocurrency amounts, encrypted by means of ElGamal encryption and recipients' public keys
let c_bar_vec: Vec<G1Point> = amounts.iter().zip(recipients_pub_keys.iter()).map(|(a, k)| ElGamal::elgamal_encrypt(*a, k, &g, &r).0).collect();

// Proof generation
let proof: SigmaYProof = SigmaYProver::new(&mut prover_trans, &r, &sender_pub_key, &recipients_pub_keys).generate_proof(&mut rng); 
// Proof verification
let result: Result<(), Error> = SigmaYVerifier::new(&mut verifier_trans, &sender_pub_key, &recipients_pub_keys, &c_vec, &c_bar_vec).verify_proof(&proof);
```