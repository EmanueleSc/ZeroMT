- [Proof System Implementation](#proof-system-implementation)
  - [External crates](#external-crates)
    - [`merlin`](#merlin)
    - [`arkworks` ecosystem](#arkworks-ecosystem)
  - [Elliptic curve of choice](#elliptic-curve-of-choice)
  - [Usage of the library](#usage-of-the-library)
    - [*ZeroMT* full proof system](#zeromt-full-proof-system)
    - [*Bulletproofs* aggregated range proof](#bulletproofs-aggregated-range-proof)
    - [$\Sigma$-protocol `sk`](#sigma-protocol-sk)
    - [$\Sigma$-protocol `r`](#sigma-protocol-r)
    - [$\Sigma$-protocol `ab`](#sigma-protocol-ab)
    - [$\Sigma$-protocol `y`](#sigma-protocol-y)

# Proof System Implementation
As the *ZeroMT* multi-transfer zero-knowledge proof system can be seen as a combination of multiple proof systems, the objective of its implementation is a library that exposes each proof system in a non-interactive form, as a single, modular unit. Given the modular design, any given user should be enabled to include in any possible application either the overall *ZeroMT* proof system or just a few of the available proof systems. Furthermore, this design permits the evaluation of the performances, in terms of execution time and memory utilization, of each of the implemented protocols.

The language that has been chosen for the implementation is **Rust** as it offers a fast way to prototype a memory-efficient program while offering a wide variety of third-party packages, there called *crates*, by means of the Cargo package manager and the community’s crate registry *crates.io*.
  
This codebase includes both the logic behind the *ZeroMT* proof system and each of the underlying proof systems from *Bulletproofs* and the four other $\Sigma$-protocols. Furthermore, it also includes a test suite to ensure the correctness of the code and a benchmarking portion aimed at the performance evaluation presented in this thesis work.

## External crates
### `merlin`

[`merlin`](https://github.com/zkcrypto/merlin) is a library that offers a Fiat-Shamir heuristic for building non-interactive proof systems by means of a STROBE based transcript while implementing such systems as if they were interactive (public-coin). 

The result of the use of `merlin` for both the prover and the verifier within a proof system codebase is the generation of a single proof message to be exchanged between the parties. Prior to the proof exchange, both the prover and the verifier interact with a transcript that models all the interaction that would occur with the opposed party. Basically, every time that, by protocol definition, a prover has to send either a scalar or an elliptic curve point to a verifier such forwarding is replaced with an interaction with the transcript, that updates its internal state with the new values. When it comes to the forwarding of a randomly-computed challenge value from the verifier to the prover the transcript comes in and generates itself a challenge value for the prover. After the prover has ended following the protocol specification, a proof is generated by combining all the elements that the prover inserted in its transcript. When given such proof, the verifier syncs its own transcript by feeding it with the same elements in the same order the prover followed.

By maintaining a pair of transcripts that are consistent for both the prover and the verifier, `merlin` ensures the correctness of the implemented protocol, hence ensuring that all the generated elements have the same values on both sides.
The peculiarity of the `merlin`'s transcript is that they can be used in multiple proof systems sequentially, as long as they are in the same order on both the prover and the verifier side. 

### `arkworks` ecosystem

Crucial for the implementation of a proof system is a library that provides all the arithmetic behind elliptic curve points and finite fields elements, i.e. all the elements that are manipulated during the protocols. All the necessities of the implementation have been fullfilled by the [`arkworks`](https://github.com/arkworks-rs) ecosystem for proof systems programming in Rust.

Moreover, the `arkworks` libraries have been employed to also include serialization and deserialization processes for both elliptic curves point and finite fields elements in the `merlin` transcript logic and in the codebase that has been written for benchmarking purposes.

## Elliptic curve of choice

For what concerns the elliptic curve underlying all the operations on elements of $\mathbb{G}$, for this first complete implementation of the ZeroMT proof systems the Barreto–Naehrig curve **BN-254** has been chosen.

## Usage of the library

### *ZeroMT* full proof system



```rust
use std::io::Error;
use ark_bn254::{Fr as ScalarField, G1Affine as G1Point};
use merlin::Transcript;
use serial_test::serial;
use zeromt::{ElGamal, Utils, ZeroMTProof, ZeroMTProver, ZeroMTVerifier};

// Random Number Generator
let mut rng = ark_std::rand::thread_rng();
// Cryptocurrency amounts to be transferred (increased by one)
let mut m: usize = 16;
// Dimension in bit of the range proof
let mut n: usize = 16;
// Prover transcript setup
let mut prover_trans: Transcript = Transcript::new(b"ZeroMTTest");
// Verifier transcript setup
let mut verifier_trans: Transcript = Transcript::new(b"ZeroMTTest");
// Random generator g
let g: G1Point = Utils::get_n_generators_berkeley(1, &mut rng)[0];
// Random generator h
let h: G1Point = Utils::get_n_generators_berkeley(1, &mut rng)[0];
// Randomness r
let r: ScalarField = Utils::get_n_random_scalars_not_zero(1, &mut rng)[0];
// Random generator u
let u: G1Point = Utils::get_n_generators_berkeley(1, &mut rng)[0];
// Vector g of random generators
let g_vec: Vec<G1Point> = Utils::get_n_generators_berkeley(m * n, &mut rng);
// Vector h of random generators
let h_vec: Vec<G1Point> = Utils::get_n_generators_berkeley(m * n, &mut rng);
// Random values for sender balance and cryptocurrency amounts to be transferred
let (balance, amounts, balance_remaining) = Utils::get_mock_balances(m, n, &mut rng);
// Random sender private key
let sender_priv_key: ScalarField = Utils::get_n_random_scalars_not_zero(1, &mut rng)[0];
// Random recipients private keys
let recipients_priv_keys: Vec<ScalarField> = Utils::get_n_random_scalars_not_zero(amounts.len(), &mut rng);
// Sender public key, generated by means of ElGamal encryption
let sender_pub_key: G1Point = ElGamal::elgamal_calculate_pub_key(&sender_priv_key, &g);
// Recipients' public keys, generated by means of ElGamal encryption
let recipients_pub_keys: Vec<G1Point> = recipients_priv_keys.iter().map(|key: &ScalarField| ElGamal::elgamal_calculate_pub_key(key, &g)).collect();
// Sender balance, encrypted by means of ElGamal encryption and sender public key
let (c_l, c_r): (G1Point, G1Point) = ElGamal::elgamal_encrypt(balance, &sender_pub_key, &g, &r);
// Factor D for ElGamal scheme
let d: G1Point = ElGamal::elgamal_d(&g, &r);
// Cryptocurrency amounts, encrypted by means of ElGamal encryption and sender public key
let c_vec: Vec<G1Point> = amounts.iter().map(|a: &usize| ElGamal::elgamal_encrypt(*a, &sender_pub_key, &g, &r).0).collect();
// Cryptocurrency amounts, encrypted by means of ElGamal encryption and recipients' public keys
let c_bar_vec: Vec<G1Point> = amounts.iter().zip(recipients_pub_keys.iter()).map(|(a, k)| ElGamal::elgamal_encrypt(*a, k, &g, &r).0).collect();

// Proof generation
let proof: ZeroMTProof = ZeroMTProver::new(&mut prover_trans, &g,&h,balance_remaining,&amounts,&g_vec,&h_vec,&u,m,n,&d,&c_r,&sender_priv_key,&r,&sender_pub_key,&recipients_pub_keys).generate_proof(&mut rng);
// Proof verification
let verification_result: Result<(), Error> = ZeroMTVerifier::new(&mut verifier_trans,&g,&h,m,n,amounts.len(),&g_vec,&h_vec,&u,&d,&c_r, &c_l,&c_vec,&c_bar_vec,&sender_pub_key,&recipients_pub_keys).verify_proof(&proof);
```

### *Bulletproofs* aggregated range proof

```rust
use ark_bn254::{Fr as ScalarField, G1Affine as G1Point};
use ark_ec::{AffineCurve, ProjectiveCurve};
use ark_ff::{Field, One, PrimeField};
use merlin::Transcript;
use std::io::Error;
use zeromt::{ InnerProof, InnerProver, InnerVerifier, RangeProof, RangeProver, RangeVerifier, Utils, };

// Random Number Generator
let mut rng = ark_std::rand::thread_rng();
// Cryptocurrency amounts to be transferred (increased by one)
let mut m: usize = 16;
// Dimension in bit of the range proof
let mut n: usize = 16;
// Prover transcript setup
let mut prover_trans: Transcript = Transcript::new(b"ZeroMTTest");
// Verifier transcript setup
let mut verifier_trans: Transcript = Transcript::new(b"ZeroMTTest");
// Random generator g
let g: G1Point = Utils::get_curve_generator();
// Random generator h
let h: G1Point = Utils::get_n_generators_berkeley(1, &mut rng)[0];
// Vector g of random generators
let g_vec: Vec<G1Point> = Utils::get_n_generators_berkeley(m * n, &mut rng);
// Vector h of random generators
let h_vec: Vec<G1Point> = Utils::get_n_generators_berkeley(m * n, &mut rng);
// Random values for sender balance and cryptocurrency amounts to be transferred
let (_balance_start, amounts, balance_remaining) = Utils::get_mock_balances(m, n, &mut rng);

// Range proof generation
let (range_proof, t_hat, l_poly_vec, r_poly_vec, _x, _y, _z): (RangeProof, ScalarField, Vec<ScalarField>, Vec<ScalarField>, ScalarField, ScalarField, ScalarField) = RangeProver::new(&mut prover_trans, &g, &h, balance_remaining, &amounts, &g_vec, &h_vec, n).generate_proof(&mut rng);
// Range proof verification
let (range_proof_result, x, y, z): (Result<(), Error>, ScalarField, ScalarField, ScalarField) = RangeVerifier::new(&mut verifier_trans, &g, &h, amounts.len(), n).verify_proof(&range_proof);

// Random generator u
let u: G1Point = Utils::get_n_generators_berkeley(1, &mut rng)[0];
// Inner-product argument setup
let h_first_vec: Vec<G1Point> = (0..m * n).map(|i: usize| { h_vec[i].mul(y.pow([(i as u64)]).inverse().unwrap().into_repr()).into_affine() }).collect();
let p: G1Point = *range_proof.get_a() + range_proof.get_s().mul(x.into_repr()).into_affine() + -Utils::inner_product_point_scalar(&g_vec, &Utils::generate_scalar_exp_vector(m * n, &ScalarField::one())).unwrap().mul((z).into_repr()).into_affine() + Utils::inner_product_point_scalar(&h_first_vec, &Utils::generate_scalar_exp_vector(m * n, &y)).unwrap().mul((z).into_repr()).into_affine() + (1..=m).map(|j: usize| { Utils::inner_product_point_scalar(&h_first_vec[((j - 1) * n)..(j * n)].to_vec(), &Utils::generate_scalar_exp_vector(n, &ScalarField::from(2))).unwrap().mul((z.pow([1 + (j as u64)])).into_repr()).into_affine() }).sum::<G1Point>();
let phu: G1Point = p + -h.mul(range_proof.get_mu().into_repr()).into_affine();

// Inner-product argument proof generation
let inner_proof: InnerProof = InnerProver::new(&mut prover_trans, &g_vec, &h_first_vec, &phu, &t_hat, &l_poly_vec, &r_poly_vec, &u).generate_proof();
// Inner-product argument proof verification
let inner_result: Result<(), Error> = InnerVerifier::new(&mut verifier_trans, &g_vec, &h_first_vec, &phu, &t_hat, &u).verify_proof_multiscalar(&inner_proof);
```
### $\Sigma$-protocol `sk`


```rust
use ark_bn254::{Fr as ScalarField, G1Affine as G1Point};
use ark_ec::{AffineCurve, ProjectiveCurve};
use ark_ff::PrimeField;
use merlin::Transcript;
use std::io::Error;
use zeromt::{SigmaSKProof, SigmaSKProver, SigmaSKVerifier, Utils, ElGamal};

// Random Number Generator
let mut rng = ark_std::rand::thread_rng();
// Cryptocurrency amounts to be transferred (increased by one)
let mut m: usize = 16;
// Dimension in bit of the range proof
let mut n: usize = 16;
// Prover transcript setup
let mut prover_trans: Transcript = Transcript::new(b"ZeroMTTest");
// Verifier transcript setup
let mut verifier_trans: Transcript = Transcript::new(b"ZeroMTTest");

// Random generator g
let g: G1Point = Utils::get_curve_generator();
// Random sender private key
let sk: ScalarField = Utils::get_n_random_scalars(1, &mut rng)[0];
// Sender public key, generated by means of ElGamal encryption
let y: G1Point = ElGamal::elgamal_calculate_pub_key(&sk, &g);

// Proof generation
let proof: SigmaSKProof = SigmaSKProver::new(&mut prover_trans, &g, &sk).generate_proof(&mut rng);
// Proof verification
let result: Result<(), Error> = SigmaSKVerifier::new(&mut verifier_trans, &g, &y).verify_proof(&proof);
                    
```
### $\Sigma$-protocol `r`

  
```rust
use ark_bn254::{Fr as ScalarField, G1Affine as G1Point};
use ark_ec::{AffineCurve, ProjectiveCurve};
use ark_ff::PrimeField;
use merlin::Transcript;
use std::io::Error;
use zeromt::{SigmaRProof, SigmaRProver, SigmaRVerifier, Utils, ElGamal};

// Random Number Generator
let mut rng = ark_std::rand::thread_rng();
// Cryptocurrency amounts to be transferred (increased by one)
let mut m: usize = 16;
// Dimension in bit of the range proof
let mut n: usize = 16;
// Prover transcript setup
let mut prover_trans: Transcript = Transcript::new(b"ZeroMTTest");
// Verifier transcript setup
let mut verifier_trans: Transcript = Transcript::new(b"ZeroMTTest");

// Random generator g
let g: G1Point = Utils::get_curve_generator();
// Randomness r
let r: ScalarField = Utils::get_n_random_scalars(1, &mut rng)[0];
// Factor D for ElGamal scheme
let d: G1Point = ElGamal::elgamal_d(&g, &r);

// Proof generation
let proof: SigmaRProof = SigmaRProver::new(&mut prover_trans, &g, &r).generate_proof(&mut rng);
// Proof verification
let result: Result<(), Error> = SigmaRVerifier::new(&mut verifier_trans, &g, &d).verify_proof(&proof);
```
### $\Sigma$-protocol `ab`
Prover $\mathcal{P}$ inputs:
- $g \in \mathbb{G}$
- $D \in \mathbb{G}$
- $C_R \in \mathbb{G}$
- $sk \in \mathbb{Z}_p$
- $\mathbf{a} \in \mathbb{Z}_p^{m-1}$
- $b' \in \mathbb{Z}_p$

Verifier $\mathcal{V}$ inputs:
- $g \in \mathbb{G}$
- $D \in \mathbb{G}$
- $C_L \in \mathbb{G}$
- $C_R \in \mathbb{G}$
- $\mathbf{C} \in \mathbb{G}^{m-1}$

```rust
use ark_bn254::{Fr as ScalarField, G1Affine as G1Point};
use merlin::Transcript;
use rand::Rng;
use std::io::Error;
use zeromt::{ElGamal, SigmaABProof, SigmaABProver, SigmaABVerifier, Utils};

// Random Number Generator
let mut rng = ark_std::rand::thread_rng();
// Cryptocurrency amounts to be transferred (increased by one)
let mut m: usize = 16;
// Dimension in bit of the range proof
let mut n: usize = 16;
// Prover transcript setup
let mut prover_trans: Transcript = Transcript::new(b"ZeroMTTest");
// Verifier transcript setup
let mut verifier_trans: Transcript = Transcript::new(b"ZeroMTTest");
// Random generator g
let g: G1Point = Utils::get_n_generators_berkeley(1, &mut rng)[0];
// Randomness r
let r: ScalarField = Utils::get_n_random_scalars_not_zero(1, &mut rng)[0];
// Random values for sender balance and cryptocurrency amounts to be transferred
let (balance, amounts, balance_remaining) = get_mock_balances(m, n, &mut rng);
// Random sender private key   
let sender_priv_key: ScalarField = Utils::get_n_random_scalars_not_zero(1, &mut rng)[0];
// Sender public key, generated by means of ElGamal encryption
let sender_pub_key: G1Point = ElGamal::elgamal_calculate_pub_key(&sender_priv_key, &g);
// Sender balance, encrypted by means of ElGamal encryption and sender public key
let (c_l, c_r): (G1Point, G1Point) = ElGamal::elgamal_encrypt(balance, &sender_pub_key, &g, &r);
// Factor D for ElGamal scheme
let d: G1Point = ElGamal::elgamal_d(&g, &r);
// Cryptocurrency amounts, encrypted by means of ElGamal encryption and sender public key
let c_vec: Vec<G1Point> = amounts.iter().map(|a:&usize| ElGamal::elgamal_encrypt(*a, &sender_pub_key, &g, &r).0).collect();

// Proof generation
let proof: SigmaABProof = SigmaABProver::new(&mut prover_trans, &g, &d, &c_r, balance_remaining, &amounts, &sender_priv_key).generate_proof(&mut rng);
// Proof verification
let result: Result<(), Error> = SigmaABVerifier::new(&mut verifier_trans, &g, &d, &c_r, &c_l, &c_vec, amounts.len()).verify_proof(&proof);

```
### $\Sigma$-protocol `y`
Prover $\mathcal{P}$ inputs:
- $y \in \mathbb{G}$, sender public key;
- $\bar{\mathbf{y}} \in \mathbb{G}^{m-1}$, recipients' public keys
- $r \in \mathbb{Z}_p$, randomness associated with the ElGamal encryption scheme;

Verifier $\mathcal{V}$ inputs:
- $y \in \mathbb{G}$, sender public key;
- $\bar{\mathbf{y}} \in \mathbb{G}^{m-1}$, recipients' public keys
- $\mathbf{C} \in \mathbb{G}^{m-1}$, cryptocurrency amounts, encrypted by means of ElGamal encryption and sender public key;
- $\bar{\mathbf{C}} \in \mathbb{G}^{m-1}$, cryptocurrency amounts, encrypted by means of ElGamal encryption and recipients' public keys;


```rust
use ark_bn254::{Fr as ScalarField, G1Affine as G1Point};
use merlin::Transcript;
use std::io::Error;
use zeromt::{ElGamal, SigmaYProof, SigmaYProver, SigmaYVerifier, Utils};

// Random Number Generator
let mut rng = ark_std::rand::thread_rng();
// Cryptocurrency amounts to be transferred (increased by one)
let mut m: usize = 16;
// Dimension in bit of the range proof
let mut n: usize = 16;
// Prover transcript setup
let mut prover_trans: Transcript = Transcript::new(b"ZeroMTTest");
// Verifier transcript setup
let mut verifier_trans: Transcript = Transcript::new(b"ZeroMTTest");
// Random generator g
let g: G1Point = Utils::get_n_generators_berkeley(1, &mut rng)[0];
// Randomness r
let r: ScalarField = Utils::get_n_random_scalars_not_zero(1, &mut rng)[0];
// Random values for sender balance and cryptocurrency amounts to be transferred
let (_balance_start, amounts, _balance_remaining) = Utils::get_mock_balances(m, n, &mut rng);
// Random sender private key
let sender_priv_key: ScalarField = Utils::get_n_random_scalars_not_zero(1, &mut rng)[0];
// Random recipients private keys
let recipients_priv_keys: Vec<ScalarField> = Utils::get_n_random_scalars_not_zero(amounts.len(), &mut rng);
// Sender public key, generated by means of ElGamal encryption
let sender_pub_key: G1Point = ElGamal::elgamal_calculate_pub_key(&sender_priv_key, &g);
// Recipients' public keys, generated by means of ElGamal encryption
let recipients_pub_keys: Vec<G1Point> = recipients_priv_keys.iter().map(|key: &ScalarField| ElGamal::elgamal_calculate_pub_key(key, &g)).collect();
// Cryptocurrency amounts, encrypted by means of ElGamal encryption and sender public key
let c_vec: Vec<G1Point> = amounts.iter().map(|a: &usize| ElGamal::elgamal_encrypt(*a, &sender_pub_key, &g, &r).0).collect();
// Cryptocurrency amounts, encrypted by means of ElGamal encryption and recipients' public keys
let c_bar_vec: Vec<G1Point> = amounts.iter().zip(recipients_pub_keys.iter()).map(|(a, k)| ElGamal::elgamal_encrypt(*a, k, &g, &r).0).collect();

// Proof generation
let proof: SigmaYProof = SigmaYProver::new(&mut prover_trans, &r, &sender_pub_key, &recipients_pub_keys).generate_proof(&mut rng); 
// Proof verification
let result: Result<(), Error> = SigmaYVerifier::new(&mut verifier_trans, &sender_pub_key, &recipients_pub_keys, &c_vec, &c_bar_vec).verify_proof(&proof);
```